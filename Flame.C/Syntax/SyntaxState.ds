using System;
using System.Collections.Generic;
using System.Text;
using Flame.Compiler;
using Flame.Compiler.Expressions;
using Flame.Compiler.Statements;
using Flame.Compiler.Variables;
using Flame.C;
using Flame.C.Build;
using Flame.C.Lexer;

namespace Flame.Syntax.C
{
    public class SyntaxState : ICSyntaxState
    {
        public const this(set CompilationUnit DeclaringUnit, set IMethod Method,
            set DeclarationScope Scope, set ICompilerLog Log,
            set IConverter<IType, string> TypeNamer)
        {
            this.Binder = new SyntaxStateBinder(this);
            this.MemberProvider = new MemberProvider(Binder);
            this.declaredVariables = new Stack<Dictionary<string, DeclaredVariable>>();
            this.declarationTypes = new Stack<bool>();
            PushVariableScope();
        }
        public const this(set CompilationUnit DeclaringUnit, set IMethod Method,
            set DeclarationScope Scope, set ICompilerLog Log,
            set IMemberProvider MemberProvider,
            set IConverter<IType, string> TypeNamer)
        {
            this.Binder = new SyntaxStateBinder(this);
            this.declaredVariables = new Stack<Dictionary<string, DeclaredVariable>>();
            this.declarationTypes = new Stack<bool>();
            PushVariableScope();
        }

        public IType CurrentType
        {
            const get
            {
                var declType = Method.DeclaringType;
                if (declType.IsGeneric && declType.IsGenericDeclaration)
                {
                	return declType.MakeGenericType((IEnumerable<IType>)declType.GetGenericParameters());
                }
                else
                {
                	return declType;
                }
            }
        }

        public CompilationUnit DeclaringUnit { const get; private set; }
        public ICompilerLog Log { const get; private set; }
        public IBinder Binder { const get; private set; }
        public IConverter<IType, string> TypeNamer { const get; private set; }
        public IMemberProvider MemberProvider { const get; private set; }
        public DeclarationScope Scope { const get; private set; }

        private Stack<Dictionary<string, DeclaredVariable>> declaredVariables;
        public Dictionary<string, DeclaredVariable> Locals
        {
            const get
            {
            	Dictionary<string, DeclaredVariable> dict = new Dictionary<string, DeclaredVariable>();
            	foreach (var map in declaredVariables)
            	foreach (var item in map)
            	{
            		dict[item.Key] = item.Value;
            	}
                return dict;
            }
        }

        public IMethod Method { const get; private set; }

		private IVariableProvider paramProvider;
        public IVariableProvider ParameterProvider
        {
            const get
            {
            	if (paramProvider == null)
            	{
            		paramProvider = new MethodParameterProvider(Method);
            	}
                return paramProvider;
            }
        }
        public IType ReturnType
        {
            const get
            {
                return Method.ReturnType;
            }
        }
        public IType DeclaringType
        {
            const get
            {
                return Method.DeclaringType;
            }
        }
        public IVariable DeclareVariable(string Name, IVariable Variable, SourceLocation Location)
        {
            var localDecls = declaredVariables.Peek();
            if (localDecls.ContainsKey(Name))
            {
                var body = RedefinitionHelpers.CreateRedefinitionNode(Name, Location, localDecls[Name].Location);
                Log.LogError(new LogEntry("Variable redefinition", body));
            }
            else if (Log.ShowShadowWarnings && VariableExists(Name))
            {
                var node = RedefinitionHelpers.CreateRedefinitionMessageNode("Variable '" + Name + "' is shadowed. [-" + Warnings.ShadowWarnings + "]",
                    Location, GetDeclarationLocation(Name));
                Log.LogWarning(new LogEntry("Variable shadowed", node));
            }
            localDecls[Name] = new DeclaredVariable(Variable, Location);
            return Variable;
        }
        public const IVariable GetVariable(string Name)
        {
            return GetDeclaredVariable(Name).Variable;
        }
        public const DeclaredVariable GetDeclaredVariable(string Name)
        {
            var localDict = Locals;
            if (localDict.ContainsKey(Name))
            {
                return localDict[Name];
            }
            else if (ParameterProvider != null && ParameterProvider.VariableExists(Name))
            {
                return new DeclaredVariable(ParameterProvider.GetVariable(Name), null);
            }
            return default(DeclaredVariable);
        }
        public const bool VariableExists(string Name)
        {
            var localDict = Locals;
            if (localDict.ContainsKey(Name))
            {
                return true;
            }
            else
            {
                return ParameterProvider != null && ParameterProvider.VariableExists(Name);
            }
        }

        private void PushVariableScope()
        {
            this.declaredVariables.Push(new Dictionary<string, DeclaredVariable>());
            PushDeclarationType(false);
        }

        public void PushScope()
        {
            PushVariableScope();
            this.Scope = new DeclarationScope(this.DeclaringUnit, this.Scope);
        }

        public IStatement PopScope()
        {
            PopDeclarationType();
            List<IStatement> statements = new List<IStatement>();
            var scopeVars = declaredVariables.Pop();
            foreach (var item in scopeVars)
            {
                statements.Add(item.Value.Variable.CreateReleaseStatement());
            }
            this.Scope = this.Scope.Parent;
            return new BlockStatement(statements.ToArray());
        }

        private Stack<bool> declarationTypes;

        public bool UseNewDeclarations
        {
            const get return declarationTypes.Peek();
        }

        public void PushDeclarationType(bool UseNewDeclarations)
        {
            declarationTypes.Push(UseNewDeclarations);
        }

        public void PopDeclarationType()
        {
            declarationTypes.Pop();
        }

        #region Declarations

        public IMethod Declare(SyntaxFunction Function)
        {
            return Scope.Declare(Function);
        }

        public IType Declare(SyntaxStruct Type)
        {
            if (UseNewDeclarations)
            {
                return Scope.DeclareNew(Type);
            }
            else
            {
                return Scope.Declare(Type);
            }
        }

        public IType Declare(SyntaxEnum Type)
        {
            if (UseNewDeclarations)
            {
                return Scope.DeclareNew(Type);
            }
            else
            {
                return Scope.Declare(Type);
            }
        }

        public IField Declare(SyntaxField Field)
        {
            return Scope.Declare(Field);
        }

        public IType Declare(SyntaxTypedef Typedef)
        {
            var result = Scope.Declare(Typedef);
            if (Typedef.Type is IRenamableType)
            {
                DeclaringUnit.Assembly.SuggestRename((IRenamableType)Typedef.Type, Typedef.Name);
            }
            return result;
        }

        #endregion
    }
}
