using System;
using System.Collections.Generic;
using System.Linq;
using Flame.Build;
using Flame.Compiler;
using Flame.C.Build;
using Pixie;

namespace Flame.Syntax.C
{
    public class DeclarationScope
    {
        public const this(set CompilationUnit Unit)
        {
            methods = new Dictionary<string, SyntaxFunction>();
            fields = new Dictionary<string, SyntaxField>();
            structs = new Dictionary<string, SyntaxStruct>();
            typedefs = new Dictionary<string, SyntaxTypedef>();
            allMethods = new Dictionary<string, IMethod>();
            allFields = new Dictionary<string, IField>();
            allStructs = new Dictionary<string, SyntaxStruct>();
            allTypedefs = new Dictionary<string, SyntaxTypedef>();
        }
        public const this(set CompilationUnit Unit, set DeclarationScope Parent)
        {
            methods = new Dictionary<string, SyntaxFunction>();
            fields = new Dictionary<string, SyntaxField>();
            structs = new Dictionary<string, SyntaxStruct>();
            typedefs = new Dictionary<string, SyntaxTypedef>();
            allMethods = new Dictionary<string, IMethod>(Parent.allMethods);
            allFields = new Dictionary<string, IField>(Parent.allFields);
            allStructs = new Dictionary<string, SyntaxStruct>(Parent.allStructs);
            allTypedefs = new Dictionary<string, SyntaxTypedef>(Parent.allTypedefs);
        }

        public CompilationUnit Unit { const get; private set; }
        public DeclarationScope Parent { const get; private set; }

        public bool IsRoot { const get return Parent == null; }

        private Dictionary<string, SyntaxFunction> methods;
        private Dictionary<string, SyntaxField> fields;
        private Dictionary<string, SyntaxStruct> structs;
        private Dictionary<string, SyntaxTypedef> typedefs;
        private Dictionary<string, IField> allFields;
        private Dictionary<string, IMethod> allMethods;
        private Dictionary<string, SyntaxStruct> allStructs;
        private Dictionary<string, SyntaxTypedef> allTypedefs;

        public static const IMarkupNode CreateRedefinitionNode(string Name,
            SourceLocation NewDefinition, SourceLocation OldDefinition)
        {
            var firstMessage = new MarkupNode(NodeConstants.TextNodeType, "'" + Name + "' is defined more than once.");
            var firstDiag = NewDefinition.CreateDiagnosticsNode();

            var oldSrc = OldDefinition.CreateSourceNode();
            var neutralOldSrc = new MarkupNode("neutral-diagnostics", new IMarkupNode[] { oldSrc });
            var oldTitle = new MarkupNode(NodeConstants.TextNodeType, "Previous definition: ");
            var oldMessage = OldDefinition.CreateLineNumberNode(NodeConstants.TextNodeType);

            var oldRemark = new MarkupNode(NodeConstants.RemarksNodeType, new IMarkupNode[]
            {
                oldTitle,
                oldMessage,
                neutralOldSrc
            });

            var totalMessage = new MarkupNode("entry", new IMarkupNode[]
            {
                firstMessage,
                firstDiag,
                oldRemark
            });

            return totalMessage;
        }

        public IMethod Declare(SyntaxFunction Method)
        {
            string name = Method.Name;
            if (!methods.ContainsKey(name))
            {
                Unit.DeclareGlobal(Method);
                methods[name] = Method;
                allMethods[name] = Method;
            }
            else if (Method.IsDefinition)
            {
                methods[name].MakeDefinition(Method);
            }
            return methods[name];
        }

        public IField Declare(SyntaxField Field)
        {
            string name = Field.Name;
            if (!fields.ContainsKey(name))
            {
                Unit.DeclareGlobal(Field);
                fields[name] = Field;
                allFields[name] = Field;
            }
            else if (Field.IsDefinition)
            {
                fields[name].MakeDefinition(Field);
            }
            return fields[name];
        }

        private void DefineStruct(SyntaxStruct Declaration, SyntaxStruct Definition)
        {
            if (Definition.IsDefinition)
            {
                if (Declaration.IsDefinition)
                {
                    Unit.Assembly.Log.LogError(new LogEntry("Type redefinition",
                        CreateRedefinitionNode(Definition.LocalName,
                            Definition.DefinitionSyntax.GetSourceLocation(),
                            Declaration.DefinitionSyntax.GetSourceLocation())));
                }
                Declaration.MakeDefinition(Definition);
                Declaration.ApplyDefinition();
            }
        }

        public IType Declare(SyntaxStruct Type)
        {
            if (Type.IsAnonymous || Type.IsDefinition)
            {
                return DeclareNew(Type);
            }

            string name = Type.TypeName;
            if (allStructs.ContainsKey(name))
            {
                var result = allStructs[name];
                DefineStruct(result, Type);
                return result;
            }

            return DeclareNew(Type);
        }

        public IType DeclareNew(SyntaxStruct Type)
        {
            if (Type.IsAnonymous)
            {
                Unit.DeclareGlobal(Type);
                return Type;
            }

            string name = Type.TypeName;
            if (!structs.ContainsKey(name))
            {
                structs[name] = Type;
                allStructs[name] = Type;
                Unit.DeclareGlobal(Type);
            }
            else
            {
                DefineStruct(structs[name], Type);
            }
            return structs[name];
        }

        public IType Declare(SyntaxTypedef Typedef)
        {
            string name = Typedef.Name;
            if (typedefs.ContainsKey(name))
            {
                var old = typedefs[name];
                if (old.Type.Equals(Typedef.Type))
                {
                    Typedef = old;
                }
                else
                {
                    Unit.Assembly.Log.LogError(new LogEntry("Typedef redefinition with different types",
                        CreateRedefinitionNode(Typedef.LocalName,
                            Typedef.DeclaratorSyntax.GetSourceLocation(),
                            old.DeclaratorSyntax.GetSourceLocation())));
                }
            }
            typedefs[name] = Typedef;
            allTypedefs[name] = Typedef;
            return Typedef;
        }

        public [IField] LocalFields { const get return fields.Values; }
        public [IMethod] LocalFunctions { const get return methods.Values; }
        public [ICType] LocalTypes
        {
            const get
                return Enumerable.Concat<ICType>(structs.Values, typedefs.Values);
        }

        public [IField] AllFields { const get return allFields.Values; }
        public [IMethod] AllFunctions { const get return allMethods.Values; }
        public [ICType] AllTypes
        {
            const get
                return Enumerable.Concat<ICType>(allStructs.Values, allTypedefs.Values);
        }
    }
}
