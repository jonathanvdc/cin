using System;
using System.Collections.Generic;
using System.Text;
using Flame.Compiler;
using Flame.C.Lexer;

namespace Flame.C.Preprocessor
{
    public class PreprocessorInstance
    {
        public const this(set ITokenStream Reader, PreprocessorEnvironment Environment)
        {
            this.State = new PreprocessorState(Environment);
            this.Builder = new TokenStreamBuilder();
        }
        public const this(set ITokenStream Reader, set PreprocessorState State)
        {
            this.Builder = new TokenStreamBuilder();
        }

        public PreprocessorState State { const get; private set; }
        public ITokenStream Reader { const get; private set; }
        public TokenStreamBuilder Builder { const get; private set; }

        public PreprocessorEnvironment Environment { const get return State.Environment; }

        private void ProcessMacro(DefineDirective Directive)
        {
            var args = ReadMacroArguments(Directive);
            var chunkReader = new MemoryTokenStream(Directive.Body.Substitute(args));
            Builder.Append(State.Expand(chunkReader));
        }

        private Token[][] ReadMacroArguments(DefineDirective Directive)
        {
            if (Directive.HasParameters)
            {
                var args = Reader.ReadMacroArguments();
                var expandedArgs = new Token[][args.Length];
                foreach (var input in args, var output in expandedArgs)
                {
                    output = State.Expand(input).ToTokens();
                }
                return expandedArgs;
            }
            else
            {
                return new Token[][] { };
            }
        }

        private void ProcessToken(Token Value)
        {
            foreach (var item in State.Definitions)
            {
                if (Value.TokenValue.Equals(item.Name))
                {
                    ProcessMacro(item);
                    return;
                }
            }
            Builder.Append(Value);
        }

        private void ProcessItem()
        {
            var val = Reader.Next();
            if (val.Type == TokenType.Hash)
            {
                ProcessDirective(val);
            }
            else
            {
                ProcessToken(val);
            }
        }

        private void ProcessDirective(Token HashToken)
        {
            var name = Reader.NextNoTrivia(TokenType.Identifier, Environment.Log);

            // Now parse the body
            var body = Reader.ReadLine();

            var parser = Environment.GetParser(name.TokenValue);
            if (parser == null)
            {
                Environment.Log.LogWarning(new LogEntry("Unknown preprocessor directive",
                    "Preprocessor directive '" + name.TokenValue + "' was not recognized.",
                    name.Location));
            }
            else
            {
                var directive = parser.Parse(HashToken, name, State, body);
                directive.Apply(this);
            }
        }

        public void Process()
        {
            while (!Reader.IsEmpty)
            {
                ProcessItem();
            }
        }
    }
}
